//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ex3ndr/Develop/actor-proprietary/actor-sdk/sdk-core/runtime/runtime-shared/src/main/java//im/actor/runtime/bser/DataInput.java
//

#include <j2objc/IOSClass.h>
#include <j2objc/IOSPrimitiveArray.h>
#include <j2objc/J2ObjC_source.h>
#include "im/actor/runtime/bser/DataInput.h"
#include "im/actor/runtime/bser/Limits.h"
#include <j2objc/java/io/IOException.h>
#include <j2objc/java/lang/IllegalArgumentException.h>
#include <j2objc/java/lang/Integer.h>

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

@interface ARDataInput () {
 @public
  IOSByteArray *data_;
  jint offset_;
  jint maxOffset_;
}

@end

J2OBJC_FIELD_SETTER(ARDataInput, data_, IOSByteArray *)

#line 0 "/Users/ex3ndr/Develop/actor-proprietary/actor-sdk/sdk-core/runtime/runtime-shared/src/main/java//im/actor/runtime/bser/DataInput.java"


#line 9
@implementation ARDataInput


#line 14
- (instancetype)initWithByteArray:(IOSByteArray *)data {
  ARDataInput_initWithByteArray_(self, data);
  return self;
}


#line 24
- (instancetype)initWithByteArray:(IOSByteArray *)data
                          withInt:(jint)offset
                          withInt:(jint)len {
  ARDataInput_initWithByteArray_withInt_withInt_(self, data, offset, len);
  return self;
}


#line 43
- (IOSByteArray *)getData {
  return data_;
}

- (jint)getMaxOffset {
  return maxOffset_;
}

- (jboolean)isEOF {
  return maxOffset_ <= offset_;
}

- (jint)getOffset {
  return offset_;
}

- (jint)getRemaining {
  return maxOffset_ - offset_;
}

- (void)skipWithInt:(jint)size {
  if (offset_ + size > maxOffset_) {
    @throw new_JavaIoIOException_init();
  }
  offset_ += size;
}

- (jint)readByte {
  if (offset_ == maxOffset_) {
    @throw new_JavaIoIOException_init();
  }
  return IOSByteArray_Get(nil_chk(data_), offset_++) & (jint) 0xFF;
}

- (jint)readInt {
  if (offset_ + 4 > maxOffset_) {
    @throw new_JavaIoIOException_init();
  }
  
#line 82
  jint res = (IOSByteArray_Get(nil_chk(data_), offset_ + 3) & (jint) 0xFF) +
#line 83
  (JreLShift32((IOSByteArray_Get(data_, offset_ + 2) & (jint) 0xFF), 8)) +
#line 84
  (JreLShift32((IOSByteArray_Get(data_, offset_ + 1) & (jint) 0xFF), 16)) +
#line 85
  (JreLShift32((IOSByteArray_Get(data_, offset_) & (jint) 0xFF), 24));
  offset_ += 4;
  return res;
}


#line 90
- (jlong)readLong {
  if (offset_ + 8 > maxOffset_) {
    @throw new_JavaIoIOException_init();
  }
  
#line 95
  jlong a1 = IOSByteArray_Get(nil_chk(data_), offset_ + 3) & (jint) 0xFF;
  jlong a2 = IOSByteArray_Get(data_, offset_ + 2) & (jint) 0xFF;
  jlong a3 = IOSByteArray_Get(data_, offset_ + 1) & (jint) 0xFF;
  jlong a4 = IOSByteArray_Get(data_, offset_ + 0) & (jint) 0xFF;
  
#line 100
  jlong res1 = (a1) + (JreLShift64(a2, 8)) + (JreLShift64(a3, 16)) + (JreLShift64(a4, 24));
  offset_ += 4;
  
#line 103
  jlong b1 = IOSByteArray_Get(data_, offset_ + 3) & (jint) 0xFF;
  jlong b2 = IOSByteArray_Get(data_, offset_ + 2) & (jint) 0xFF;
  jlong b3 = IOSByteArray_Get(data_, offset_ + 1) & (jint) 0xFF;
  jlong b4 = IOSByteArray_Get(data_, offset_ + 0) & (jint) 0xFF;
  
#line 108
  jlong res2 = (b1) + (JreLShift64(b2, 8)) + (JreLShift64(b3, 16)) + (JreLShift64(b4, 24));
  offset_ += 4;
  
#line 111
  return res2 + (JreLShift64(res1, 32));
}


#line 114
- (jlong)readUInt {
  if (offset_ + 4 > maxOffset_) {
    @throw new_JavaIoIOException_init();
  }
  
#line 119
  jlong a1 = IOSByteArray_Get(nil_chk(data_), offset_ + 3) & (jint) 0xFF;
  jlong a2 = IOSByteArray_Get(data_, offset_ + 2) & (jint) 0xFF;
  jlong a3 = IOSByteArray_Get(data_, offset_ + 1) & (jint) 0xFF;
  jlong a4 = IOSByteArray_Get(data_, offset_ + 0) & (jint) 0xFF;
  offset_ += 4;
  return (a1) + (JreLShift64(a2, 8)) + (JreLShift64(a3, 16)) + (JreLShift64(a4, 24));
}


#line 127
- (IOSByteArray *)readBytesWithInt:(jint)count {
  
#line 129
  if (count < 0) {
    @throw new_JavaIoIOException_initWithNSString_(@"Count can't be negative");
  }
  
#line 133
  if (count > ARLimits_MAX_BLOCK_SIZE) {
    @throw new_JavaIoIOException_initWithNSString_(@"Unable to read more than 1 MB");
  }
  
#line 137
  if (offset_ + count > maxOffset_) {
    @throw new_JavaIoIOException_initWithNSString_(JreStrcat("$I$I", @"Too many to read, max len: ", maxOffset_, @", required len: ", (offset_ + count)));
  }
  
#line 141
  IOSByteArray *res = [IOSByteArray newArrayWithLength:count];
  for (jint i = 0; i < count; i++) {
    *IOSByteArray_GetRef(res, i) = IOSByteArray_Get(nil_chk(data_), offset_++);
  }
  return res;
}


#line 148
- (jint)readVarInt32 {
  jlong varInt = [self readVarInt];
  if (varInt > JavaLangInteger_MAX_VALUE || varInt < JavaLangInteger_MIN_VALUE) {
    @throw new_JavaIoIOException_initWithNSString_(@"Too big VarInt32");
  }
  return (jint) varInt;
}

- (jlong)readVarInt {
  jlong value = 0;
  jlong i = 0;
  jlong b;
  
#line 161
  do {
    if (offset_ == maxOffset_) {
      @throw new_JavaIoIOException_init();
    }
    
#line 166
    b = IOSByteArray_Get(nil_chk(data_), offset_++) & (jint) 0xFF;
    
#line 168
    if ((b & (jint) 0x80) != 0) {
      value |= JreLShift64((b & (jint) 0x7F), i);
      i += 7;
      if (i > 70) {
        @throw new_JavaIoIOException_init();
      }
    }
    else {
      
#line 175
      break;
    }
  }
  while (
#line 177
  true);
  
#line 179
  return value | (JreLShift64(b, i));
}


#line 182
- (IOSByteArray *)readProtoBytes {
  jlong len = [self readVarInt];
  if (len < 0) {
    @throw new_JavaIoIOException_init();
  }
  if (len > ARLimits_MAX_BLOCK_SIZE) {
    @throw new_JavaIoIOException_init();
  }
  return [self readBytesWithInt:(jint) len];
}

- (IOSLongArray *)readProtoLongs {
  jlong len = [self readVarInt];
  if (len < 0) {
    @throw new_JavaIoIOException_init();
  }
  if (len > ARLimits_MAX_PROTO_REPEATED) {
    @throw new_JavaIoIOException_init();
  }
  
#line 202
  IOSLongArray *res = [IOSLongArray newArrayWithLength:(jint) len];
  for (jint i = 0; i < res->size_; i++) {
    *IOSLongArray_GetRef(res, i) = [self readLong];
  }
  return res;
}


#line 209
- (NSString *)readProtoString {
  IOSByteArray *data = [self readProtoBytes];
  return [NSString stringWithBytes:data charsetName:@"UTF-8"];
}

- (jboolean)readProtoBool {
  return [self readByte] != 0;
}

- (jint)readASN1Length {
  jint length = [self readByte];
  if (length < 0) {
    @throw new_JavaIoIOException_initWithNSString_(@"EOF found when length expected");
  }
  
#line 224
  if (length == (jint) 0x80) {
    return -1;
  }
  
#line 228
  if (length > 127) {
    jint size = length & (jint) 0x7f;
    
#line 232
    if (size > 4) {
      @throw new_JavaIoIOException_initWithNSString_(JreStrcat("$I", @"DER length more than 4 bytes: ", size));
    }
    
#line 236
    length = 0;
    for (jint i = 0; i < size; i++) {
      jint next = [self readByte];
      length = (JreLShift32(length, 8)) + next;
    }
    
#line 242
    if (length < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"corrupted stream - negative length found");
    }
  }
  
#line 252
  return length;
}

- (jint)readASN1Tag {
  jint tag = [self readByte];
  if (tag == 0) {
    @throw new_JavaIoIOException_init();
  }
  return tag;
}

- (jint)readASN1TagNumberWithInt:(jint)tag {
  
#line 265
  jint tagNo = tag & (jint) 0x1f;
  
#line 270
  if (tagNo == (jint) 0x1f) {
    tagNo = 0;
    
#line 273
    jint b = [self readByte];
    
#line 277
    if ((b & (jint) 0x7f) == 0) {
      
#line 279
      @throw new_JavaIoIOException_initWithNSString_(@"corrupted stream - invalid high tag number found");
    }
    
#line 282
    while ((b >= 0) && ((b & (jint) 0x80) != 0)) {
      tagNo |= (b & (jint) 0x7f);
      JreLShiftAssignInt(&tagNo, 7);
      b = [self readByte];
    }
    
#line 288
    if (b < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"EOF found inside tag value.");
    }
    
#line 292
    tagNo |= (b & (jint) 0x7f);
  }
  
#line 295
  return tagNo;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithByteArray:", "DataInput", NULL, 0x1, NULL, NULL },
    { "initWithByteArray:withInt:withInt:", "DataInput", NULL, 0x1, NULL, NULL },
    { "getData", NULL, "[B", 0x1, NULL, NULL },
    { "getMaxOffset", NULL, "I", 0x1, NULL, NULL },
    { "isEOF", NULL, "Z", 0x1, NULL, NULL },
    { "getOffset", NULL, "I", 0x1, NULL, NULL },
    { "getRemaining", NULL, "I", 0x1, NULL, NULL },
    { "skipWithInt:", "skip", "V", 0x1, "Ljava.io.IOException;", NULL },
    { "readByte", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "readInt", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "readLong", NULL, "J", 0x1, "Ljava.io.IOException;", NULL },
    { "readUInt", NULL, "J", 0x1, "Ljava.io.IOException;", NULL },
    { "readBytesWithInt:", "readBytes", "[B", 0x1, "Ljava.io.IOException;", NULL },
    { "readVarInt32", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "readVarInt", NULL, "J", 0x1, "Ljava.io.IOException;", NULL },
    { "readProtoBytes", NULL, "[B", 0x1, "Ljava.io.IOException;", NULL },
    { "readProtoLongs", NULL, "[J", 0x1, "Ljava.io.IOException;", NULL },
    { "readProtoString", NULL, "Ljava.lang.String;", 0x1, "Ljava.io.IOException;", NULL },
    { "readProtoBool", NULL, "Z", 0x1, "Ljava.io.IOException;", NULL },
    { "readASN1Length", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "readASN1Tag", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "readASN1TagNumberWithInt:", "readASN1TagNumber", "I", 0x1, "Ljava.io.IOException;", NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "data_", NULL, 0x2, "[B", NULL, NULL, .constantValue.asLong = 0 },
    { "offset_", NULL, 0x2, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "maxOffset_", NULL, 0x2, "I", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _ARDataInput = { 2, "DataInput", "im.actor.runtime.bser", NULL, 0x1, 22, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_ARDataInput;
}

@end


#line 14
void ARDataInput_initWithByteArray_(ARDataInput *self, IOSByteArray *data) {
  (void) NSObject_init(self);
  
#line 15
  if (data == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"data can't be null");
  }
  
#line 19
  self->data_ = data;
  self->offset_ = 0;
  self->maxOffset_ = ((IOSByteArray *) nil_chk(data))->size_;
}


#line 14
ARDataInput *new_ARDataInput_initWithByteArray_(IOSByteArray *data) {
  ARDataInput *self = [ARDataInput alloc];
  ARDataInput_initWithByteArray_(self, data);
  return self;
}


#line 24
void ARDataInput_initWithByteArray_withInt_withInt_(ARDataInput *self, IOSByteArray *data, jint offset, jint len) {
  (void) NSObject_init(self);
  
#line 25
  if (data == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"data can't be null");
  }
  if (offset < 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Offset can't be negative");
  }
  if (len < 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Length can't be negative");
  }
  if (((IOSByteArray *) nil_chk(data))->size_ < offset + len) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I$I", @"Inconsistent lengths, total: ", data->size_, @", offset: ", offset, @", len: ", len));
  }
  
#line 38
  self->data_ = data;
  self->offset_ = offset;
  self->maxOffset_ = offset + len;
}


#line 24
ARDataInput *new_ARDataInput_initWithByteArray_withInt_withInt_(IOSByteArray *data, jint offset, jint len) {
  ARDataInput *self = [ARDataInput alloc];
  ARDataInput_initWithByteArray_withInt_withInt_(self, data, offset, len);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ARDataInput)

#pragma clang diagnostic pop
